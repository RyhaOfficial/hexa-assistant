import subprocess
import os
import sys
import json
import logging
import requests
import time
import threading
from typing import List, Dict, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
from pathlib import Path

# Third-party imports
try:
    from metasploit import module as msf
    from cryptography.fernet import Fernet
    import nmap
    import psutil
    from stem import Signal
    from stem.control import Controller
    import shodan
    from pyvmomi import vim
    from transformers import pipeline
except ImportError:
    print("Installing required dependencies...")
    subprocess.run([sys.executable, "-m", "pip", "install", "-r", "requirements.txt"])

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('exploit_finder.log'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

class VulnerabilitySeverity(Enum):
    CRITICAL = 4
    HIGH = 3
    MEDIUM = 2
    LOW = 1

class VulnerabilityType(Enum):
    BUFFER_OVERFLOW = "CWE-119"
    SQL_INJECTION = "CWE-89"
    XSS = "CWE-79"
    CSRF = "CWE-352"
    RCE = "CWE-78"
    PRIVILEGE_ESCALATION = "CWE-269"
    INFORMATION_DISCLOSURE = "CWE-200"
    DENIAL_OF_SERVICE = "CWE-400"
    OTHER = "CWE-OTHER"

@dataclass
class Vulnerability:
    cve_id: str
    severity: VulnerabilitySeverity
    type: VulnerabilityType
    description: str
    affected_systems: List[str]
    cvss_score: float
    exploit_available: bool
    exploit_path: Optional[str] = None
    proof_of_concept: Optional[str] = None

@dataclass
class Exploit:
    vulnerability: Vulnerability
    source: str  # e.g., "Exploit-DB", "Metasploit", "GitHub"
    payload: str
    success_rate: float
    requirements: List[str]
    verification_status: str  # "Verified", "Unverified", "Failed"
    code: str

class ExploitFinder:
    def __init__(self, target: str, output_dir: str):
        self.target = target
        self.output_dir = Path(output_dir)
        self.vulnerabilities: List[Vulnerability] = []
        self.exploits: List[Exploit] = []
        self.is_running = False
        self.tor_enabled = False
        
        # Create output directory if it doesn't exist
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        # Initialize AI model for exploit generation
        self.exploit_generator = pipeline("text-generation", model="gpt2")
        
        # Initialize Shodan client
        self.shodan_client = shodan.Shodan(os.getenv("SHODAN_API_KEY"))
        
    def enable_tor(self):
        """Enable Tor for anonymous operations"""
        try:
            with Controller.from_port(port=9051) as controller:
                controller.authenticate()
                controller.signal(Signal.NEWNYM)
                self.tor_enabled = True
                logger.info("Tor connection established successfully")
        except Exception as e:
            logger.error(f"Failed to enable Tor: {e}")
            
    def scan_vulnerabilities(self) -> List[Vulnerability]:
        """Scan target for vulnerabilities using multiple tools"""
        logger.info(f"Starting vulnerability scan for {self.target}")
        vulnerabilities = []
        
        # Nmap scan
        try:
            nm = nmap.PortScanner()
            nm.scan(self.target, arguments='-sV --script vuln')
            
            for host in nm.all_hosts():
                for port in nm[host].all_ports():
                    if 'script' in nm[host][port]:
                        for script in nm[host][port]['script']:
                            if 'VULNERABLE' in nm[host][port]['script'][script]:
                                vuln = Vulnerability(
                                    cve_id=f"CVE-{time.time()}",  # Placeholder
                                    severity=VulnerabilitySeverity.HIGH,
                                    type=VulnerabilityType.OTHER,
                                    description=nm[host][port]['script'][script],
                                    affected_systems=[host],
                                    cvss_score=7.0,
                                    exploit_available=True
                                )
                                vulnerabilities.append(vuln)
        except Exception as e:
            logger.error(f"Nmap scan failed: {e}")
            
        # CVE API integration
        try:
            response = requests.get(f"https://cve.circl.lu/api/search/{self.target}")
            if response.status_code == 200:
                cve_data = response.json()
                for cve in cve_data:
                    vuln = Vulnerability(
                        cve_id=cve['id'],
                        severity=VulnerabilitySeverity.HIGH if float(cve.get('cvss', 0)) >= 7.0 else VulnerabilitySeverity.MEDIUM,
                        type=VulnerabilityType.OTHER,  # Would need mapping from CWE
                        description=cve.get('summary', 'No description available'),
                        affected_systems=[self.target],
                        cvss_score=float(cve.get('cvss', 0)),
                        exploit_available=True if cve.get('exploit-db', False) else False
                    )
                    vulnerabilities.append(vuln)
        except Exception as e:
            logger.error(f"CVE API query failed: {e}")
            
        # Shodan scan
        try:
            results = self.shodan_client.search(self.target)
            for result in results['matches']:
                if 'vulns' in result:
                    for vuln in result['vulns']:
                        vuln = Vulnerability(
                            cve_id=vuln,
                            severity=VulnerabilitySeverity.HIGH,
                            type=VulnerabilityType.OTHER,
                            description=f"Vulnerability found in {result['ip_str']}",
                            affected_systems=[result['ip_str']],
                            cvss_score=7.0,
                            exploit_available=True
                        )
                        vulnerabilities.append(vuln)
        except Exception as e:
            logger.error(f"Shodan scan failed: {e}")
            
        self.vulnerabilities = vulnerabilities
        return vulnerabilities
    
    def find_exploits(self) -> List[Exploit]:
        """Find and prepare exploits for identified vulnerabilities"""
        logger.info("Searching for available exploits")
        exploits = []
        
        for vuln in self.vulnerabilities:
            # Search in Metasploit
            try:
                msf_results = msf.search(vuln.cve_id)
                if msf_results:
                    exploit = Exploit(
                        vulnerability=vuln,
                        source="Metasploit",
                        payload=msf_results[0]['path'],
                        success_rate=0.8,
                        requirements=['metasploit'],
                        verification_status="Verified",
                        code=msf_results[0]['code']
                    )
                    exploits.append(exploit)
                    continue
            except Exception as e:
                logger.error(f"Metasploit search failed: {e}")
                
            # Search in Exploit-DB
            try:
                response = requests.get(f"https://www.exploit-db.com/search?cve={vuln.cve_id}")
                if response.status_code == 200 and 'application/json' in response.headers.get('content-type', ''):
                    exploit_data = response.json()
                    if exploit_data.get('data'):
                        exploit = Exploit(
                            vulnerability=vuln,
                            source="Exploit-DB",
                            payload=exploit_data['data'][0]['Path'],
                            success_rate=0.7,
                            requirements=['exploit-db'],
                            verification_status="Unverified",
                            code=exploit_data['data'][0]['Code']
                        )
                        exploits.append(exploit)
            except Exception as e:
                logger.error(f"Exploit-DB search failed: {e}")
                
            # Generate AI-based exploit if no public exploit found
            if not exploits:
                try:
                    generated_exploit = self.generate_ai_exploit(vuln)
                    if generated_exploit:
                        exploits.append(generated_exploit)
                except Exception as e:
                    logger.error(f"AI exploit generation failed: {e}")
                
        self.exploits = exploits
        return exploits
    
    def generate_ai_exploit(self, vulnerability: Vulnerability) -> Optional[Exploit]:
        """Generate an exploit using AI models"""
        logger.info(f"Generating AI-based exploit for {vulnerability.cve_id}")
        
        try:
            # Generate exploit code using AI
            prompt = f"Generate exploit code for {vulnerability.cve_id} targeting {vulnerability.affected_systems[0]}"
            generated_code = self.exploit_generator(prompt, max_length=500)[0]['generated_text']
            
            exploit = Exploit(
                vulnerability=vulnerability,
                source="AI-Generated",
                payload="custom",
                success_rate=0.5,  # Lower success rate for AI-generated exploits
                requirements=['python'],
                verification_status="Unverified",
                code=generated_code
            )
            
            return exploit
            
        except Exception as e:
            logger.error(f"Failed to generate AI exploit: {e}")
            return None
    
    def verify_exploit(self, exploit: Exploit) -> bool:
        """Verify the effectiveness of an exploit"""
        logger.info(f"Verifying exploit for {exploit.vulnerability.cve_id}")
        
        try:
            # Create isolated environment for testing
            # This is a placeholder - actual implementation would use Docker or VM
            test_result = True  # Replace with actual verification
            
            if test_result:
                exploit.verification_status = "Verified"
                exploit.success_rate = min(exploit.success_rate + 0.1, 1.0)
            else:
                exploit.verification_status = "Failed"
                exploit.success_rate = max(exploit.success_rate - 0.1, 0.0)
                
            return test_result
            
        except Exception as e:
            logger.error(f"Exploit verification failed: {e}")
            return False
    
    def generate_report(self):
        """Generate a detailed report of vulnerabilities and exploits"""
        logger.info("Generating vulnerability and exploit report")
        
        report = {
            'target': self.target,
            'timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
            'vulnerabilities': [vars(v) for v in self.vulnerabilities],
            'exploits': [vars(e) for e in self.exploits],
            'summary': {
                'total_vulnerabilities': len(self.vulnerabilities),
                'total_exploits': len(self.exploits),
                'critical_vulnerabilities': sum(1 for v in self.vulnerabilities if v.severity == VulnerabilitySeverity.CRITICAL),
                'verified_exploits': sum(1 for e in self.exploits if e.verification_status == "Verified")
            }
        }
        
        # Save report in multiple formats
        report_path = self.output_dir / f"exploit_report_{int(time.time())}"
        
        # JSON format
        with open(f"{report_path}.json", 'w') as f:
            json.dump(report, f, indent=4)
            
        # HTML format
        html_report = self._generate_html_report(report)
        with open(f"{report_path}.html", 'w') as f:
            f.write(html_report)
            
        # Markdown format
        markdown_report = self._generate_markdown_report(report)
        with open(f"{report_path}.md", 'w') as f:
            f.write(markdown_report)
            
        logger.info(f"Reports generated: {report_path}.*")
        
    def _generate_html_report(self, report: Dict) -> str:
        """Generate HTML report"""
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Exploit Finder Report - {report['target']}</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                .vulnerability {{ margin: 10px 0; padding: 10px; border: 1px solid #ccc; }}
                .critical {{ background-color: #ffcccc; }}
                .high {{ background-color: #ffddcc; }}
                .medium {{ background-color: #ffffcc; }}
                .low {{ background-color: #ccffcc; }}
            </style>
        </head>
        <body>
            <h1>Exploit Finder Report</h1>
            <h2>Target: {report['target']}</h2>
            <p>Generated: {report['timestamp']}</p>
            
            <h3>Summary</h3>
            <ul>
                <li>Total Vulnerabilities: {report['summary']['total_vulnerabilities']}</li>
                <li>Total Exploits: {report['summary']['total_exploits']}</li>
                <li>Critical Vulnerabilities: {report['summary']['critical_vulnerabilities']}</li>
                <li>Verified Exploits: {report['summary']['verified_exploits']}</li>
            </ul>
            
            <h3>Vulnerabilities</h3>
            {self._generate_vulnerability_html(report['vulnerabilities'])}
            
            <h3>Exploits</h3>
            {self._generate_exploit_html(report['exploits'])}
        </body>
        </html>
        """
        return html
        
    def _generate_markdown_report(self, report: Dict) -> str:
        """Generate Markdown report"""
        markdown = f"""
        # Exploit Finder Report
        
        ## Target: {report['target']}
        Generated: {report['timestamp']}
        
        ## Summary
        - Total Vulnerabilities: {report['summary']['total_vulnerabilities']}
        - Total Exploits: {report['summary']['total_exploits']}
        - Critical Vulnerabilities: {report['summary']['critical_vulnerabilities']}
        - Verified Exploits: {report['summary']['verified_exploits']}
        
        ## Vulnerabilities
        {self._generate_vulnerability_markdown(report['vulnerabilities'])}
        
        ## Exploits
        {self._generate_exploit_markdown(report['exploits'])}
        """
        return markdown
        
    def _generate_vulnerability_html(self, vulnerabilities: List[Dict]) -> str:
        """Generate HTML for vulnerabilities section"""
        html = ""
        for vuln in vulnerabilities:
            severity_class = vuln['severity'].lower()
            html += f"""
            <div class="vulnerability {severity_class}">
                <h4>{vuln['cve_id']}</h4>
                <p>Severity: {vuln['severity']}</p>
                <p>Type: {vuln['type']}</p>
                <p>Description: {vuln['description']}</p>
                <p>CVSS Score: {vuln['cvss_score']}</p>
                <p>Affected Systems: {', '.join(vuln['affected_systems'])}</p>
            </div>
            """
        return html
        
    def _generate_exploit_html(self, exploits: List[Dict]) -> str:
        """Generate HTML for exploits section"""
        html = ""
        for exploit in exploits:
            html += f"""
            <div class="exploit">
                <h4>{exploit['vulnerability']['cve_id']}</h4>
                <p>Source: {exploit['source']}</p>
                <p>Success Rate: {exploit['success_rate']}</p>
                <p>Verification Status: {exploit['verification_status']}</p>
                <pre><code>{exploit['code']}</code></pre>
            </div>
            """
        return html
        
    def _generate_vulnerability_markdown(self, vulnerabilities: List[Dict]) -> str:
        """Generate Markdown for vulnerabilities section"""
        markdown = ""
        for vuln in vulnerabilities:
            markdown += f"""
            ### {vuln['cve_id']}
            - Severity: {vuln['severity']}
            - Type: {vuln['type']}
            - Description: {vuln['description']}
            - CVSS Score: {vuln['cvss_score']}
            - Affected Systems: {', '.join(vuln['affected_systems'])}
            """
        return markdown
        
    def _generate_exploit_markdown(self, exploits: List[Dict]) -> str:
        """Generate Markdown for exploits section"""
        markdown = ""
        for exploit in exploits:
            markdown += f"""
            ### {exploit['vulnerability']['cve_id']}
            - Source: {exploit['source']}
            - Success Rate: {exploit['success_rate']}
            - Verification Status: {exploit['verification_status']}
            ```python
            {exploit['code']}
            ```
            """
        return markdown

def main():
    """Main function to demonstrate usage"""
    target = "example.com"  # Replace with actual target
    finder = ExploitFinder(target=target, output_dir="reports")
    
    # Enable Tor for anonymity
    finder.enable_tor()
    
    # Scan for vulnerabilities
    vulnerabilities = finder.scan_vulnerabilities()
    logger.info(f"Found {len(vulnerabilities)} vulnerabilities")
    
    # Find exploits
    exploits = finder.find_exploits()
    logger.info(f"Found {len(exploits)} exploits")
    
    # Verify exploits
    for exploit in exploits:
        finder.verify_exploit(exploit)
    
    # Generate report
    finder.generate_report()

if __name__ == "__main__":
    main()
